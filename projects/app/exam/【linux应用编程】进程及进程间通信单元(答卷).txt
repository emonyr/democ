1.D
2.A
3.C
4.C
5.A
6.A
7.A
8.B
9.C
10.D
11.B
12.B
13.C
14.A
15.B

二、
1.F
2.T
3.T
4.T
5.T
6.T
7.F
8.T
9.T
10.T
11.F
12.F
13.T
14.N
15.T

三、
1.
程序是指用户空间执行的代码以及相应的堆栈空间
进程除了包含程序用户空间的内容外，还包含了内核空间为其分配的资源，如内存页信息，进程结构体，IPC资源等。

2.
静态库是编译时使用 -static 参数把库包含在程序内，使得程序在缺乏库支持的系统环境得以运行
如果系统支持共享库，就不需要静态编译，连接器会指向共享库的位置，这样程序会比较轻量级

3.
设置信号处理函数
sighandler_t signal(int signum,sig_handler_t handler)
用户定义的信号处理函数
typedef void (*sig_handler_t)(int signum)

4.
info1 from child process_2
info1 from child process_1
info1 from parent process
info2 from parent process

5.
管道
share memory
信号
信号量

四、
1.
1)fork出子进程，然后杀死对应的父进程
2)禁止终端重新被打开
3)关闭file_fd
4)切换工作目录到 /
5)清除umask

2.
附件截图

3.

reader.c:

int main(int argc,const char **argv)
{
	int fifo_fd,content,sval;
	char buf[1024];

	sval = umask(0);
	fifo_fd = mkfifo(“/home/linux/myfifo”,0666);
	if(fifo_fd == EEXIST ){
		fifo_fd = open(“/home/linux/myfifo”,O_WRONLY);
	}

	content = open(argv[1],O_RDONLY);
	if(content == -1 ){
		perror(“open”);exit;
	}

	while(read(content,buf,1024)){
		write(fifo_fd,buf,1024);
	}
	umask(sval);
	pause();
	close(content);
	close(fifo_fd);
	return 0;
}


writer.c:

int main(int argc,const char **argv)
{
	int fifo_fd,content,sval;
	char buf[1024];

	sval = umask(0);
	fifo_fd = open(“/home/linux/myfifo”,O_RDONLY);
	if(fifd_fd == -1){
		perror(“open”);exit;
	}

	content = open(argv[1],O_WRONLY|O_CREAT);
	if(content == -1 ){
		perror(“open”);exit;
	}

	while(read(fifo_fd,buf,1024)){
		write(content,buf,1024);
	}
	umask(sval);
	close(content);
	close(fifo_fd);
	return 0;
}





