【实验一】：计算本机的标准IO缓存大小
	1.1 请验证stdout是行缓存、stderr是不缓存
		【提示】：使用fprintf函数，分别向stdout和stderr写入有行标志的字符串及无行标志的字符串。
	1.2 请验证文件对象的标准IO是全缓存IO。
	1.3 请计算标准IO中缓存区的大小
		【提示】；不断的向标准IO写入数据，写入的数据正好溢出到屏幕时，就是一个缓存区的大小了。
	/*提示代码，请分析*/
	#include <stdio.h>
	int main()
	{
		int i=0;	
		for(i=0;i<379;i++)//每次向缓冲区内写三个字符
		{
			if(i>=100)
				fprintf(stdout,"%d",i);
			else if (i>=10)
				fprintf(stdout,"0%d",i);
			else if (i>=0)
				fprintf(stdout,"00%d",i);
		}
		while(1);//强制执行，如果取消，程序结束时将会输出所有字符，看不到效果了。
	}
【实验二】：文件拷贝
	通过一个简单的copy程序，完成文件的复制程序。
	扩展：
		2.1 使用fgets这样的行IO方式，设计程序
		2.2 使用fgetc这样的字符IO方式，设计程序
		2.3 使用fread这样的块IO方式，设计程序
		
【实验三】：文件添加方式
	使用标准IO方式，完成如下功能
	编程读写一个文件test.txt，每隔1秒向文件中写入一行数据，类似这样
		1,  2007-7-30 15:16:42
		2,  2007-7-30 15:16:43

	该程序应该无限循环，直到按Ctrl-C中断程序。下次再启动程序写文件时可以追加到原文件之后，并且序号能够接续上次的序号，比如：
		1,  2007-7-30 15:16:42
		2,  2007-7-30 15:16:43
		3,  2007-7-30 15:19:02
		4,  2007-7-30 15:19:03
		5,  2007-7-30 15:19:04
		
	【实验提示】
		要追加写入文件，同时要读取该文件的内容以决定下一个序号是几，应该用什么模式打开文件？ 
		首先判断一下打开的文件是否为新文件，如果是新文件，就从序号1开始写入；
		如果不是新文件，则统计原来有多少行，比如有n行，然后从序号n+1开始写入。以后每写一行就把行号加1。 
		获取当前的系统时间需要调用函数time()，得到的结果是一个time_t类型，其实就是一个大整数，
		其值表示从UTC时间1970年1月1日00:00:00（称为UNIX的Epoch时间）到当前时刻的秒钟数。
		然后调用localtime()将time_t所表示的UTC时间转换为本地时间（我们是+8区，比UTC多8个小时）并转成struct tm类型，该类型的各数据成员分别表示年月日时分秒，请自己写出转换格式的代码，不要使用ctime()或asctime()函数。
		具体用法请查阅man page。time和localtime函数需要头文件time.h。 
		调用sleep(n)可使程序睡眠n秒，该函数需要头文件unistd.h。 